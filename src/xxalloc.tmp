#include <gmacs.htp>

model_data::model_data(int argc,char * argv[]) : ad_comm(argc,argv)
{
 ///> flag for simulating data 
		simflag = 0;
		rseed   = 0;
		int opt,on;
		/**
		 * @brief command line option for simulating data.
		 */
		if((on=option_match(ad_comm::argc,ad_comm::argv,"-sim",opt))>-1)
		{
			simflag = 1;
			rseed   = atoi(ad_comm::argv[on+1]);
		}
		if((on=option_match(ad_comm::argc,ad_comm::argv,"-i",opt))>-1)
		{
			cout<<"\n";
			cout<<"  |----------------------------------------------------------|\n";
			cout<<"  | CONTRIBUTIONS (code and intellectual)                    |\n";
			cout<<"  |----------------------------------------------------------|\n";
			cout<<"  | Name:                        Organization:               |\n";
			cout<<"  | James Ianelli                NOAA-NMFS                   |\n";
			cout<<"  | D'Arcy Webber                NOAA-NMFS Contractor        |\n";
			cout<<"  | Steven Martell               IPHC                        |\n";
			cout<<"  | Jack Turnock                 NOAA-NMFS                   |\n";
			cout<<"  | Jie Zheng 	                ADF&G                       |\n";
			cout<<"  | Hamachan Hamazaki 	        ADF&G                       |\n";
			cout<<"  | Athol Whitten                University of Washington    |\n";
			cout<<"  | Andre Punt                   University of Washington    |\n";
			cout<<"  | Dave Fournier                Otter Research              |\n";
			cout<<"  | John Levitt                  Mathemetician               |\n";
			cout<<"  |----------------------------------------------------------|\n";
			cout<<"\n";
			cout<<"  |----------------------------------------------------------|\n";
			cout<<"  | FINANCIAL SUPPORT                                        |\n";
			cout<<"  |----------------------------------------------------------|\n";
			cout<<"  | Financial support for this project was provided by the   |\n";
			cout<<"  | National Marine Fisheries Service, the Bering Sea        |\n";
			cout<<"  | Fisheries Research Foundation,....                       |\n";
			cout<<"  |----------------------------------------------------------|\n";
			cout<<"\n";
			cout<<"  |----------------------------------------------------------|\n";
			cout<<"  | DOCUMENTATION                                            |\n";
			cout<<"  |----------------------------------------------------------|\n";
			cout<<"  | online api: http://seacode.github.io/gmacs/index.html    |\n";
			cout<<"  |----------------------------------------------------------|\n";
			cout<<"\n";
			exit(1);
		}
		// Command line option here to do retrospective analysis
		if((on=option_match(ad_comm::argc,ad_comm::argv,"-retro",opt))>-1)
		{
			cout<<"\n";
			cout<<"  |----------------------------------------------------------|\n";
			cout<<"  | Running retrospective model with "<< ad_comm::argv[on+1]<<" recent yrs removed |\n";
			cout<<"  |----------------------------------------------------------|\n";
			cout<<"  |  YET TO BE IMPLEMENTED                                   |\n";
			cout<<"  |----------------------------------------------------------|\n";
			exit(1);
		}
  datafile.allocate("datafile");
  controlfile.allocate("controlfile");
 ad_comm::change_datafile_name(datafile); WriteFileName(datafile); WriteFileName(controlfile);
  syr.allocate("syr");
  nyr.allocate("nyr");
  jstep.allocate("jstep");
  nfleet.allocate("nfleet");
  nsex.allocate("nsex");
  nshell.allocate("nshell");
  nmature.allocate("nmature");
  nclass.allocate("nclass");
		WRITEDAT(syr); 
		WRITEDAT(nyr); 
		WRITEDAT(jstep); 
		WRITEDAT(nfleet); 
		WRITEDAT(nsex); 
		WRITEDAT(nshell);
		WRITEDAT(nmature);
		WRITEDAT(nclass);
 n_grp = nsex * nshell * nmature;
 nlikes = 5; // (catch, cpue, sizecomps, recruits, molt_increment data)
  isex.allocate(1,n_grp);
  ishell.allocate(1,n_grp);
  imature.allocate(1,n_grp);
  pntr_hmo.allocate(1,nsex,1,nmature,1,nshell);
		int h,m,o;
		int hmo=1;
		for( h = 1; h <= nsex; h++ )
		{
			for( m = 1; m <= nmature; m++ )
			{
				for( o = 1; o <= nshell; o++ )
				{
					isex(hmo) = h;
					ishell(hmo) = o;
					imature(hmo) = m;
					pntr_hmo(h,m,o) = hmo++;
				}
			}
		}
  size_breaks.allocate(1,nclass+1,"size_breaks");
  mid_points.allocate(1,nclass);
 mid_points = size_breaks(1,nclass) + 0.5 * first_difference(size_breaks);
  WRITEDAT(size_breaks);
  lw_alfa.allocate(1,nsex,"lw_alfa");
  lw_beta.allocate(1,nsex,"lw_beta");
  mean_wt.allocate(1,nsex,1,nclass);
		for(int h = 1; h <= nsex; h++ )
		{
			mean_wt(h) = lw_alfa(h) * pow(mid_points,lw_beta(h));
		}
 WRITEDAT(lw_alfa); WRITEDAT(lw_beta); ECHO(mean_wt);
  fecundity.allocate(1,nclass,"fecundity");
  maturity.allocate(1,nsex,1,nclass,"maturity");
 WRITEDAT(fecundity); WRITEDAT(maturity); 
  name_read_flt.allocate("name_read_flt");
  name_read_srv.allocate("name_read_srv");
 WRITEDAT(name_read_srv); WRITEDAT(name_read_flt);
  nCatchDF.allocate("nCatchDF");
  nCatchRows.allocate(1,nCatchDF,"nCatchRows");
  dCatchData.allocate(1,nCatchDF,1,nCatchRows,1,11,"dCatchData");
  obs_catch.allocate(1,nCatchDF,1,nCatchRows);
  catch_cv.allocate(1,nCatchDF,1,nCatchRows);
  catch_dm.allocate(1,nCatchDF,1,nCatchRows);
  catch_mult.allocate(1,nCatchDF,1,nCatchRows);
		for(int k = 1; k <= nCatchDF; k++ )
		{
			catch_mult(k) = column(dCatchData(k),9);
			obs_catch(k)  = column(dCatchData(k),5);
			catch_cv(k)   = column(dCatchData(k),6);
			catch_dm(k)   = column(dCatchData(k),11);
			obs_catch(k) = elem_prod(obs_catch(k),catch_mult(k)); // rescale catch by multiplier
		}
		WRITEDAT(nCatchDF); WRITEDAT(nCatchRows); WRITEDAT(dCatchData);
  nFparams.allocate(1,nfleet);
  nYparams.allocate(1,nfleet);
  foff_phz.allocate(1,nfleet);
  fhit.allocate(syr,nyr,1,nfleet);
  yhit.allocate(syr,nyr,1,nfleet);
  dmr.allocate(syr,nyr,1,nfleet);
		nFparams.initialize();
		nYparams.initialize();
		fhit.initialize();
		yhit.initialize();
		dmr.initialize();
		foff_phz = -1;
		for(int k = 1; k <= nCatchDF; k++ )
		{
			for(int i = 1; i <= nCatchRows(k); i++ )
			{
				int g = dCatchData(k)(i,3); // fleet
				int y = dCatchData(k)(i,1); // year
				int h = dCatchData(k)(i,4); // sex
				if(!fhit(y,g))
				{
					fhit(y,g)   ++;
					nFparams(g) ++;
					dmr(y,g) = catch_dm(k)(i);
				}
				if(!yhit(y,g) && h == 2)
				{
					yhit(y,g)   ++;
					nYparams(g) ++;
					foff_phz(g) = 1;
					dmr(y,g) = catch_dm(k)(i);
				}
			}
		}
  nSurveys.allocate("nSurveys");
  nSurveyRows.allocate(1,nSurveys,"nSurveyRows");
  dSurveyData.allocate(1,nSurveys,1,nSurveyRows,1,7,"dSurveyData");
  obs_cpue.allocate(1,nSurveys,1,nSurveyRows);
  cpue_cv.allocate(1,nSurveys,1,nSurveyRows);
		for(int k = 1; k <= nSurveys; k++ )
		{
			obs_cpue(k) = column(dSurveyData(k),5);
			cpue_cv(k)  = column(dSurveyData(k),6);
		}
		WRITEDAT(nSurveys);WRITEDAT(nSurveyRows);WRITEDAT(dSurveyData); 
		ECHO(obs_cpue); ECHO(cpue_cv); 
  nSizeComps.allocate("nSizeComps");
  nSizeCompRows.allocate(1,nSizeComps,"nSizeCompRows");
  nSizeCompCols.allocate(1,nSizeComps,"nSizeCompCols");
  d3_SizeComps.allocate(1,nSizeComps,1,nSizeCompRows,-7,nSizeCompCols,"d3_SizeComps");
  d3_obs_size_comps.allocate(1,nSizeComps,1,nSizeCompRows,1,nSizeCompCols);
  d3_res_size_comps.allocate(1,nSizeComps,1,nSizeCompRows,1,nSizeCompCols);
  size_comp_sample_size.allocate(1,nSizeComps,1,nSizeCompRows);
		for(int k = 1; k <= nSizeComps; k++)
		{
			dmatrix tmp = trans(d3_SizeComps(k)).sub(1,nSizeCompCols(k));
			d3_obs_size_comps(k) = trans(tmp);
			// NOTE This normalizes all observations by row--may be incorrect if shell condition
			for (int i=1;i<=nSizeCompRows(k);i++)
			{
			   d3_obs_size_comps(k,i) /= sum(d3_obs_size_comps(k,i));
			}
			size_comp_sample_size(k) = column(d3_SizeComps(k),0);
		}
		WRITEDAT(nSizeComps);WRITEDAT(nSizeCompRows);  WRITEDAT(nSizeCompCols); WRITEDAT(d3_SizeComps); ECHO(d3_obs_size_comps); 
  ilike_vector.allocate(1,nlikes);
	  ilike_vector(1) = nCatchDF;
	  ilike_vector(2) = nSurveys;
	  ilike_vector(3) = nSizeComps;
	  ilike_vector(4) = 1;
	  ilike_vector(5) = 1;
  nGrowthObs.allocate("nGrowthObs");
  dGrowthData.allocate(1,nGrowthObs,1,4,"dGrowthData");
  dPreMoltSize.allocate(1,nGrowthObs);
  iMoltIncSex.allocate(1,nGrowthObs);
  dMoltInc.allocate(1,nGrowthObs);
  dMoltIncCV.allocate(1,nGrowthObs);
  mle_alpha.allocate(1,nsex);
  mle_beta.allocate(1,nsex);
		dPreMoltSize = column(dGrowthData,1);
		iMoltIncSex  = ivector(column(dGrowthData,2));
		dMoltInc     = column(dGrowthData,3);
		dMoltIncCV   = column(dGrowthData,4);
		dvector xybar(1,nsex);
		dvector xx(1,nsex);
		dvector xbar(1,nsex);
		dvector ybar(1,nsex);
		ivector nh(1,nsex);
		nh.initialize();
		xybar.initialize();
		xbar.initialize();
		ybar.initialize();
		xx.initialize();
		// come up with mle estimates for alpha and beta
		// for the linear growth increment model.
		if(nGrowthObs)
		{
			for(int i = 1; i <= nGrowthObs; i++ )
			{
				int h = iMoltIncSex(i);
				
				nh(h)++;
				xybar(h) += dPreMoltSize(i) * dMoltInc(i);
				xbar(h)  += dPreMoltSize(i); 
				ybar(h)  += dMoltInc(i);
				xx(h)    += square(dPreMoltSize(i));
			}
			for( h = 1; h <= nsex; h++ )
			{
				xybar(h) /= nh(h);
				xbar(h)  /= nh(h);
				ybar(h)  /= nh(h);
				xx(h)    /= nh(h);
				double slp = (xybar(h) - xbar(h)*ybar(h)) / (xx(h) - square(xbar(h)));
				double alp = ybar(h) - slp*xbar(h);
				mle_alpha(h) = alp;
				mle_beta(h)  = -slp;
			}
						
		}
	  WRITEDAT(nGrowthObs); 
	  WRITEDAT(dGrowthData); 
	  ECHO(dPreMoltSize); 
	  ECHO(iMoltIncSex); 
	  ECHO(dMoltInc); 
	  ECHO(dMoltIncCV); 
  eof.allocate("eof");
 WRITEDAT(eof);
 if (eof != 9999) {cout<<"Error reading data"<<endl; exit(1);}
 ad_comm::change_datafile_name(controlfile);
 cout<<"*** Reading control file ***"<<endl;
  ntheta.allocate("ntheta");
  theta_control.allocate(1,ntheta,1,7,"theta_control");
  theta_ival.allocate(1,ntheta);
  theta_lb.allocate(1,ntheta);
  theta_ub.allocate(1,ntheta);
  theta_phz.allocate(1,ntheta);
		theta_ival = column(theta_control,1);
		theta_lb   = column(theta_control,2);
		theta_ub   = column(theta_control,3);
		theta_phz  = ivector(column(theta_control,4));
 nGrwth = nsex*5;
  Grwth_control.allocate(1,nGrwth,1,7,"Grwth_control");
  Grwth_ival.allocate(1,nGrwth);
  Grwth_lb.allocate(1,nGrwth);
  Grwth_ub.allocate(1,nGrwth);
  Grwth_phz.allocate(1,nGrwth);
		// ipar_vector = nsex;
		Grwth_ival  = column(Grwth_control,1);
		Grwth_lb    = column(Grwth_control,2);
		Grwth_ub    = column(Grwth_control,3);
		Grwth_phz   = ivector(column(Grwth_control,4));
		WriteCtl(ntheta); 
		WriteCtl(theta_control); 
		WriteCtl(Grwth_control);
 nr = 2 * nfleet;
 nc = 13;
  slx_nsel_blocks.allocate(1,nr,"slx_nsel_blocks");
 nslx = sum(slx_nsel_blocks);
  slx_nret.allocate(1,nsex,1,nfleet,"slx_nret");
  slx_control.allocate(1,nslx,1,nc,"slx_control");
 	WriteCtl(slx_nsel_blocks); WriteCtl(slx_nret); WriteCtl(slx_control);
  slx_indx.allocate(1,nslx);
  slx_type.allocate(1,nslx);
  slx_phzm.allocate(1,nslx);
  slx_bsex.allocate(1,nslx);
  slx_xnod.allocate(1,nslx);
  slx_inod.allocate(1,nslx);
  slx_rows.allocate(1,nslx);
  slx_cols.allocate(1,nslx);
  slx_mean.allocate(1,nslx);
  slx_stdv.allocate(1,nslx);
  slx_lam1.allocate(1,nslx);
  slx_lam2.allocate(1,nslx);
  slx_lam3.allocate(1,nslx);
  slx_styr.allocate(1,nslx);
  slx_edyr.allocate(1,nslx);
		slx_indx = ivector(column(slx_control,1));
		slx_type = ivector(column(slx_control,2));
		slx_mean = column(slx_control,3);
		slx_stdv = column(slx_control,4);
		slx_bsex = ivector(column(slx_control,5));
		slx_xnod = ivector(column(slx_control,6));
		slx_inod = ivector(column(slx_control,7));
		slx_phzm = ivector(column(slx_control,8));
		slx_lam1 = column(slx_control,9);
		slx_lam2 = column(slx_control,10);
		slx_lam3 = column(slx_control,11);
		slx_styr = ivector(column(slx_control,12));
		slx_edyr = ivector(column(slx_control,13));
		// count up number of parameters required
		slx_rows.initialize();
		slx_cols.initialize();
		for(int k = 1; k <= nslx; k++ )
		{
			/* multiplier for sex dependent selex */
			int bsex = 1;
			if(slx_bsex(k)) bsex = 2;   
			
			switch (slx_type(k))
			{
				case 1: // coefficients
					slx_cols(k) = nclass - 1;
					slx_rows(k) = bsex;
				break;
				case 2: // logistic
					slx_cols(k) = 2;
					slx_rows(k) = bsex;
				break;
				case 3: // logistic95
					slx_cols(k) = 2;
					slx_rows(k) = bsex;
				break;
			}
			// ivector tmp = ivector(slx_control(k).sub(12,11+slx_nsel_blocks(k)));
			// slx_blks(k) = tmp.shift(1);
		}
  q_controls.allocate(1,nSurveys,1,4,"q_controls");
  prior_qbar.allocate(1,nSurveys);
  prior_qsd.allocate(1,nSurveys);
  prior_qtype.allocate(1,nSurveys);
  cpue_lambda.allocate(1,nSurveys);
		prior_qtype = column(q_controls,1);
		prior_qbar  = column(q_controls,2);
		prior_qsd   = column(q_controls,3);
		cpue_lambda = column(q_controls,4);
		WriteCtl(q_controls); 
		ECHO(prior_qtype); 
		ECHO(prior_qbar); 
		ECHO(prior_qsd); 
		ECHO(cpue_lambda);
  f_controls.allocate(1,nfleet,1,4,"f_controls");
  f_phz.allocate(1,nfleet);
  pen_fbar.allocate(1,nfleet);
  log_pen_fbar.allocate(1,nfleet);
  pen_fstd.allocate(1,2,1,nfleet);
		pen_fbar = column(f_controls,1);
		log_pen_fbar = log(pen_fbar+1.0e-14);
		for(int i=1; i<=2; i++)
			pen_fstd(i) = trans(f_controls)(i+1);
		f_phz = ivector(column(f_controls,4));
		// Set foff_phz to f_phz
		for(int k = 1; k <= nfleet; k++ )
		{
			for(int i = syr; i <= nyr; i++ )
			{
				if( yhit(i,k) ) 
				{
					foff_phz(k) = f_phz(k);
					break;
				}
			}           
		}
		WriteCtl(f_controls); ECHO(f_phz); 
  nAgeCompType.allocate(1,nSizeComps,"nAgeCompType");
  bTailCompression.allocate(1,nSizeComps,"bTailCompression");
  nvn_phz.allocate(1,nSizeComps,"nvn_phz");
  iCompAggregator.allocate(1,nSizeComps,"iCompAggregator");
		for(int k = 1; k <= nSizeComps; k++ )
		{
			dmatrix tmp = trans(d3_SizeComps(k)).sub(1,nSizeCompCols(k));
			d3_obs_size_comps(k) = trans(tmp);
			// NOTE This normalizes all observations by row--may be incorrect if shell condition
			for (int i=1;i<=nSizeCompRows(k);i++)
			{
			   d3_obs_size_comps(k,i) /= sum(d3_obs_size_comps(k,i));
			}
			size_comp_sample_size(k) = column(d3_SizeComps(k),0);
		}
		//WRITEDAT(nSizeComps); WRITEDAT(nSizeCompRows); WRITEDAT(nSizeCompCols); WRITEDAT(d3_SizeComps); ECHO(d3_obs_size_comps);
	WriteCtl(nAgeCompType); WriteCtl(bTailCompression); WriteCtl(nvn_phz); 
  m_type.allocate("m_type");
  Mdev_phz.allocate("Mdev_phz");
  m_stdev.allocate("m_stdev");
  m_nNodes.allocate("m_nNodes");
  m_nodeyear.allocate(1,m_nNodes,"m_nodeyear");
		switch( m_type )
		{
			case 0:
				nMdev = 0; 
				Mdev_phz = -1;
			break;
			case 1: 
				nMdev = nyr-syr; 
			break;
			case 2:
				nMdev = m_nNodes;
			break;
			case 3:
				nMdev = m_nNodes;
			break;
		}
		WriteCtl(m_type); WriteCtl(Mdev_phz); WriteCtl(m_stdev); WriteCtl(m_nNodes); WriteCtl(m_nodeyear); 
  model_controls.allocate(1,10,"model_controls");
		rdv_phz             = int(model_controls(1));
		verbose             = int(model_controls(2));
		bInitializeUnfished = int(model_controls(3));
		spr_syr             = int(model_controls(4));
		spr_nyr             = int(model_controls(5));
		spr_target          =     model_controls(6);
		spr_fleet           = int(model_controls(7));
		spr_lambda          =     model_controls(8);
		bUseEmpiricalGrowth = int(model_controls(9));
		nSRR_flag           = int(model_controls(10));
		WriteCtl(model_controls); 
  eof_ctl.allocate("eof_ctl");
 WriteCtl(eof_ctl); 
	if(eof_ctl!=9999){cout<<"Error reading control file"<<endl; exit(1);}
 cout<<"end of control section"<<endl;
		// ensure the phase for alpha & beta is -ve for GrowhtPars if bUseEmpiricalGrowth
		COUT(Grwth_phz);
		if(bUseEmpiricalGrowth)
		{
			cerr << "WARNING:\n \tUsing empirical growth increment data,\n";
			cerr << "\talpha & beta parameters will not be estimated."<<endl;
			for (int h=1;h<=nsex;h++)
			{
				int icnt=h;
				Grwth_phz(icnt) = -1;
				icnt += nsex;
				Grwth_phz(icnt) = -1;
			}
		}
 nf = 0;
}

void model_parameters::initializationfunction(void)
{
  theta.set_initial_value(theta_ival);
  Grwth.set_initial_value(Grwth_ival);
  log_fbar.set_initial_value(log_pen_fbar);
}

model_parameters::model_parameters(int sz,int argc,char * argv[]) : 
 model_data(argc,argv) , function_minimizer(sz)
{
  initializationfunction();
  theta.allocate(1,ntheta,theta_lb,theta_ub,theta_phz,"theta");
  Grwth.allocate(1,nGrwth,Grwth_lb,Grwth_ub,Grwth_phz,"Grwth");
  log_slx_pars.allocate(1,nslx,1,slx_rows,1,slx_cols,-15,15,slx_phzm,"log_slx_pars");
		for(int k = 1; k <= nslx; k++ )
		{
			if(slx_type(k) == 2 || slx_type(k) == 3)
			{
				for(int j = 1; j <= slx_rows(k); j++ )
				{
					log_slx_pars(k)(j,1) = log(slx_mean(k));
					log_slx_pars(k)(j,2) = log(slx_stdv(k));
				}
			}
		//COUT(log_slx_pars(k));
		}
  log_fbar.allocate(1,nfleet,f_phz,"log_fbar");
  log_fdev.allocate(1,nfleet,1,nFparams,f_phz,"log_fdev");
  log_foff.allocate(1,nfleet,foff_phz,"log_foff");
  log_fdov.allocate(1,nfleet,1,nYparams,foff_phz,"log_fdov");
  rec_ini.allocate(1,nclass,-7.0,7.0,rdv_phz,"rec_ini");
  rec_dev.allocate(syr+1,nyr,-7.0,7.0,rdv_phz,"rec_dev");
  m_dev.allocate(1,nMdev,-3.0,3.0,Mdev_phz,"m_dev");
  log_vn.allocate(1,nSizeComps,nvn_phz,"log_vn");
  nloglike.allocate(1,nlikes,1,ilike_vector,"nloglike");
  #ifndef NO_AD_INITIALIZE
    nloglike.initialize();
  #endif
  nlogPenalty.allocate(1,6,"nlogPenalty");
  #ifndef NO_AD_INITIALIZE
    nlogPenalty.initialize();
  #endif
  priorDensity.allocate(1,ntheta+nGrwth+nSurveys,"priorDensity");
  #ifndef NO_AD_INITIALIZE
    priorDensity.initialize();
  #endif
  objfun.allocate("objfun");
  prior_function_value.allocate("prior_function_value");
  likelihood_function_value.allocate("likelihood_function_value");
  fpen.allocate("fpen");
  #ifndef NO_AD_INITIALIZE
  fpen.initialize();
  #endif
  M0.allocate("M0");
  #ifndef NO_AD_INITIALIZE
  M0.initialize();
  #endif
  logR0.allocate("logR0");
  #ifndef NO_AD_INITIALIZE
  logR0.initialize();
  #endif
  logRbar.allocate("logRbar");
  #ifndef NO_AD_INITIALIZE
  logRbar.initialize();
  #endif
  logRini.allocate("logRini");
  #ifndef NO_AD_INITIALIZE
  logRini.initialize();
  #endif
  ra.allocate("ra");
  #ifndef NO_AD_INITIALIZE
  ra.initialize();
  #endif
  rbeta.allocate("rbeta");
  #ifndef NO_AD_INITIALIZE
  rbeta.initialize();
  #endif
  logSigmaR.allocate("logSigmaR");
  #ifndef NO_AD_INITIALIZE
  logSigmaR.initialize();
  #endif
  steepness.allocate("steepness");
  #ifndef NO_AD_INITIALIZE
  steepness.initialize();
  #endif
  rho.allocate("rho");
  #ifndef NO_AD_INITIALIZE
  rho.initialize();
  #endif
  alpha.allocate(1,nsex,"alpha");
  #ifndef NO_AD_INITIALIZE
    alpha.initialize();
  #endif
  beta.allocate(1,nsex,"beta");
  #ifndef NO_AD_INITIALIZE
    beta.initialize();
  #endif
  gscale.allocate(1,nsex,"gscale");
  #ifndef NO_AD_INITIALIZE
    gscale.initialize();
  #endif
  molt_mu.allocate(1,nsex,"molt_mu");
  #ifndef NO_AD_INITIALIZE
    molt_mu.initialize();
  #endif
  molt_cv.allocate(1,nsex,"molt_cv");
  #ifndef NO_AD_INITIALIZE
    molt_cv.initialize();
  #endif
  rec_sdd.allocate(1,nclass,"rec_sdd");
  #ifndef NO_AD_INITIALIZE
    rec_sdd.initialize();
  #endif
  recruits.allocate(syr,nyr,"recruits");
  #ifndef NO_AD_INITIALIZE
    recruits.initialize();
  #endif
  res_recruit.allocate(syr,nyr,"res_recruit");
  #ifndef NO_AD_INITIALIZE
    res_recruit.initialize();
  #endif
  xi.allocate(syr,nyr,"xi");
  #ifndef NO_AD_INITIALIZE
    xi.initialize();
  #endif
  survey_q.allocate(1,nSurveys,"survey_q");
  #ifndef NO_AD_INITIALIZE
    survey_q.initialize();
  #endif
  pre_catch.allocate(1,nCatchDF,1,nCatchRows,"pre_catch");
  #ifndef NO_AD_INITIALIZE
    pre_catch.initialize();
  #endif
  res_catch.allocate(1,nCatchDF,1,nCatchRows,"res_catch");
  #ifndef NO_AD_INITIALIZE
    res_catch.initialize();
  #endif
  pre_cpue.allocate(1,nSurveys,1,nSurveyRows,"pre_cpue");
  #ifndef NO_AD_INITIALIZE
    pre_cpue.initialize();
  #endif
  res_cpue.allocate(1,nSurveys,1,nSurveyRows,"res_cpue");
  #ifndef NO_AD_INITIALIZE
    res_cpue.initialize();
  #endif
  molt_increment.allocate(1,nsex,1,nclass,"molt_increment");
  #ifndef NO_AD_INITIALIZE
    molt_increment.initialize();
  #endif
  molt_probability.allocate(1,nsex,1,nclass,"molt_probability");
  #ifndef NO_AD_INITIALIZE
    molt_probability.initialize();
  #endif
  growth_transition.allocate(1,nsex,1,nclass,1,nclass,"growth_transition");
  #ifndef NO_AD_INITIALIZE
    growth_transition.initialize();
  #endif
  M.allocate(1,nsex,syr,nyr,1,nclass,"M");
  #ifndef NO_AD_INITIALIZE
    M.initialize();
  #endif
  Z.allocate(1,nsex,syr,nyr,1,nclass,"Z");
  #ifndef NO_AD_INITIALIZE
    Z.initialize();
  #endif
  F.allocate(1,nsex,syr,nyr,1,nclass,"F");
  #ifndef NO_AD_INITIALIZE
    F.initialize();
  #endif
  P.allocate(1,nsex,1,nclass,1,nclass,"P");
  #ifndef NO_AD_INITIALIZE
    P.initialize();
  #endif
  d3_N.allocate(1,n_grp,syr,nyr+1,1,nclass,"d3_N");
  #ifndef NO_AD_INITIALIZE
    d3_N.initialize();
  #endif
  ft.allocate(1,nfleet,1,nsex,syr,nyr,"ft");
  #ifndef NO_AD_INITIALIZE
    ft.initialize();
  #endif
  d3_newShell.allocate(1,nsex,syr,nyr+1,1,nclass,"d3_newShell");
  #ifndef NO_AD_INITIALIZE
    d3_newShell.initialize();
  #endif
  d3_oldShell.allocate(1,nsex,syr,nyr+1,1,nclass,"d3_oldShell");
  #ifndef NO_AD_INITIALIZE
    d3_oldShell.initialize();
  #endif
  d3_pre_size_comps.allocate(1,nSizeComps,1,nSizeCompRows,1,nSizeCompCols,"d3_pre_size_comps");
  #ifndef NO_AD_INITIALIZE
    d3_pre_size_comps.initialize();
  #endif
  d3_res_size_comps.allocate(1,nSizeComps,1,nSizeCompRows,1,nSizeCompCols,"d3_res_size_comps");
  #ifndef NO_AD_INITIALIZE
    d3_res_size_comps.initialize();
  #endif
  S.allocate(1,nsex,syr,nyr,1,nclass,1,nclass,"S");
  #ifndef NO_AD_INITIALIZE
    S.initialize();
  #endif
  log_slx_capture.allocate(1,nfleet,1,nsex,syr,nyr,1,nclass,"log_slx_capture");
  #ifndef NO_AD_INITIALIZE
    log_slx_capture.initialize();
  #endif
  log_slx_retaind.allocate(1,nfleet,1,nsex,syr,nyr,1,nclass,"log_slx_retaind");
  #ifndef NO_AD_INITIALIZE
    log_slx_retaind.initialize();
  #endif
  log_slx_discard.allocate(1,nfleet,1,nsex,syr,nyr,1,nclass,"log_slx_discard");
  #ifndef NO_AD_INITIALIZE
    log_slx_discard.initialize();
  #endif
  sd_log_recruits.allocate(syr,nyr,"sd_log_recruits");
  sd_log_ssb.allocate(syr,nyr,"sd_log_ssb");
}

void model_parameters::preliminary_calculations(void)
{

#if defined(USE_ADPVM)

  admaster_slave_variable_interface(*this);

#endif
	if( simflag )
	{
		if(!global_parfile)
		{
			cerr << "Must have a gmacs.pin file to use the -sim command line option"<<endl;
			ad_exit(1);
		}
		cout<<"|———————————————————————————————————————————|"<<endl;
		cout<<"|*** RUNNING SIMULATION WITH RSEED = "<<rseed<<" ***|"<<endl;
		cout<<"|———————————————————————————————————————————|"<<endl;
		simulation_model();
		//exit(1);
	}
	
	if(bUseEmpiricalGrowth)
	{
		int l = 1;
		for(int i = 1; i <= nGrowthObs; i++ )
		{
			int h = dGrowthData(i,2);
			molt_increment(h)(l++) = dGrowthData(i,3);
			if(l > nclass) l=1;
		}
	}
}

void model_parameters::userfunction(void)
{
  objfun =0.0;
	// Initialize model parameters
	initialize_model_parameters();
	if(verbose == 1) cout<<"Ok after initializing model parameters ..."<<endl;
	// Fishing fleet dynamics ...
	calc_selectivities();
	calc_fishing_mortality();
	if(verbose == 1) cout<<"Ok after fleet dynamics ..."<<endl;
	// Population dynamics ...
	if(!bUseEmpiricalGrowth)
	{
		calc_growth_increments();
	}
	calc_molting_probability();
	calc_growth_transition();
	calc_natural_mortality();
	calc_total_mortality();
	calc_recruitment_size_distribution();
	calc_initial_numbers_at_length();
	update_population_numbers_at_length();
	calc_stock_recruitment_relationship();
	if(verbose == 1) cout<<"Ok after population dynamcs ..."<<endl;
	// observation models ...
	calc_predicted_catch();
	calc_relative_abundance();
	calc_predicted_composition();
	if( verbose == 1 ) cout<<"Ok after observation models ..."<<endl;
	// objective function ...
	calculate_prior_densities();
	calc_objective_function();
	if( verbose == 1 ) cout<<"Ok after objective function ..."<<endl;
	// sd_report variables
	if(last_phase()) 
	{
		calc_sdreport();
	}
	nf++;
	/**
	 * @brief calculate sdreport variables in final phase
	 */
}

void model_parameters::calc_sdreport(void)
{
	sd_log_recruits = log(recruits);
	sd_log_ssb = log(calc_ssb());
	//for(int k = 1; k <= nfleet; k++ )
	//{
	//	sd_fbar(k) = mean(ft(k));
	//	
	//}
	/**
	 * @brief Initialize model parameters
	 * @details Set global variable equal to the estimated parameter vectors.
	 * 
	 * SM:  Note if using empirical growth increment data, then alpha and beta
         * Growth parameters should not be estimated.  Need to warn the user
         * if the following condition is true:
         * if( bUseEmpiricalGrowth && ( acitve(alpha) || active(beta) ) )
	 */
}

void model_parameters::initialize_model_parameters(void)
{
	// Get parameters from theta control matrix:
	M0        = theta(1);
	logR0     = theta(2);
	logRini   = theta(3);
	logRbar   = theta(4);
	ra        = theta(5);
	rbeta     = theta(6);
	logSigmaR = theta(7);
	steepness = theta(8);
	rho       = theta(9);
	// init_bounded_number_vector Grwth(1,nGrwth,Grwth_lb,Grwth_ub,Grwth_phz);
	// Get Growth & Molting parameters 
	for (int h=1;h<=nsex;h++)
	{
		int icnt=h;
		alpha(h)     = Grwth(icnt);
		icnt += nsex;
		beta(h)      = Grwth(icnt);
		icnt += nsex;
		gscale(h)    = Grwth(icnt);
		icnt += nsex;
		molt_mu(h)   = Grwth(icnt);
		icnt += nsex;
		molt_cv(h)   = Grwth(icnt);
	}
	if( !bUseEmpiricalGrowth )
	{
		alpha     = mle_alpha;
		beta      = mle_beta;
	}
	/**
	 * @brief Calculate selectivies for each gear.
	 * @author Steve Martell
	 * @details Three selectivities must be accounted for by each fleet.
	 * 1) capture probability, 2) retention probability, and 3) release probability.
	 * 
	 * Maintain the possibility of estimating selectivity independently for
	 * each sex; assumes there are data to estimate female selex.
	 * 
	 * BUG: There should be no retention of female crabs in the directed fishery.
	 * 
	 * Psuedocode:
	 *  -# Loop over each gear:
	 *  -# Create a pointer array with length = number of blocks
	 *  -# Based on slx_type, fill pointer with parameter estimates.
	 *  -# Loop over years and block-in the log_selectivity at mid points.
	 * 	
	 * Need to deprecate the abstract class for selectivity, 7X slower. 
	 */
}

void model_parameters::calc_selectivities(void)
{
	int h,i,j,k;
	int block;
	dvariable p1,p2;
	dvar_vector pv;
	log_slx_capture.initialize();
	log_slx_discard.initialize();
	log_slx_retaind.initialize();
	for( k = 1; k <= nslx; k++ )
	{   
		block = 1;
		gsm::Selex<dvar_vector> * pSLX[slx_rows(k)-1];
		for( j = 0; j < slx_rows(k); j++ )
		{
			switch (slx_type(k))
			{
			case 1:  //coefficients
				pv   = mfexp(log_slx_pars(k)(block));
				pSLX[j] = new gsm::SelectivityCoefficients<dvar_vector>(pv);
			break;
			case 2:  //logistic
				p1 = mfexp(log_slx_pars(k,block,1));
				p2 = mfexp(log_slx_pars(k,block,2));
				pSLX[j] = new gsm::LogisticCurve<dvar_vector,dvariable>(p1,p2);
			break;
			case 3:  // logistic95
				p1 = mfexp(log_slx_pars(k,block,1));
				p2 = mfexp(log_slx_pars(k,block,2));
				pSLX[j] = new gsm::LogisticCurve95<dvar_vector,dvariable>(p1,p2);
			break;
			}
			block ++;
		}
		// fill array with selectivity coefficients
		j = 0;
		for( h = 1; h <= nsex; h++ )
		{
			for( i = slx_styr(k); i <= slx_edyr(k); i++ )
			{
				int kk = abs(slx_indx(k));   // gear index
				if(slx_indx(k) > 0)
				{
					log_slx_capture(kk)(h)(i) = pSLX[j]->logSelectivity(mid_points);
				}
				else
				{
					log_slx_retaind(kk)(h)(i) = pSLX[j]->logSelectivity(mid_points);
					log_slx_discard(kk)(h)(i) = log(1.0 - exp(log_slx_retaind(kk)(h)(i)) +TINY);
				}
			}
			// Increment counter if sex-specific selectivity curves are defined.
			if(slx_bsex(k))  j++;
		}
		delete *pSLX;
	}
	/**
	 * @brief Calculate fishing mortality rates for each fleet.
	 * @details For each fleet estimate scaler log_fbar and deviates (f_devs).
         *
         * dmr is the discard mortality rate
	 * 
	 * In the event that there is effort data and catch data, then it's possible
	 * to estimate a catchability coefficient and predict the catch for the
	 * period of missing catch/discard data.  Best option for this would be
	 * to use F = q*E, where q = F/E.  Then in the objective function, minimize
	 * the variance in the estimates of q, and use the mean q to predict catch.
	 * Or minimize the first difference and assume a random walk in q.
	 * 
	 * Note that this function calculates the fishing mortality rate including
	 * deaths due to discards.  Where xi is the discard mortality rate.
	 * 
	 * Note also that Jie estimates F for retained fishery, f for male discards and
	 * f for female discards.  Not recommended to have separate F's for retained and 
	 * discard fisheries, but might be ok to have sex-specific F's.  
	 * 
	 * TODO 
	 * -[ ] fix discard mortality rate.
	 */
}

void model_parameters::calc_fishing_mortality(void)
{
	int h,i,k,ik,yk;
	double xi; // discard mortality rate
	F.initialize();
	ft.initialize();
	dvariable log_ftmp;
	dvar_vector sel(1,nclass);
	dvar_vector ret(1,nclass);
	dvar_vector vul(1,nclass);
	for( k = 1; k <= nfleet; k++ )
	{
		for( h = 1; h <= nsex; h++ )
		{
			ik=1; yk=1;
			for( i = syr; i <= nyr; i++ )
			{
				if(fhit(i,k))
				{
					log_ftmp = log_fbar(k) + log_fdev(k,ik++);
					if(yhit(i,k))
					{
						log_ftmp += (h-1) * (log_foff(k) + log_fdov(k,yk++));
					}
					ft(k)(h)(i) = mfexp(log_ftmp);
					xi = dmr(i,k);                                       // Discard mortality rate
					sel = exp(log_slx_capture(k)(h)(i));                 // Selectivity
					ret = exp(log_slx_retaind(k)(h)(i)) * slx_nret(h,k); // Retension
					vul = elem_prod(sel, ret + (1.0 - ret) * xi);        // Vulnerability
					/*if(sum(tmp)==0 || min(tmp) < 0)
					{
						cerr <<"Selectivity vector for gear "<<k<<" is all 0's ";
						cerr <<"Please fix the selectivity controls."<<endl;
						COUT(vul);
						exit(1);
					}
					*/
					F(h)(i) += ft(k,h,i) * vul;
				}
			}
		}
	}
	/**
	 * @brief Compute growth increments 
	 * @details Presently based on liner form
	 * 
	 * @param vSizes is a vector of doubles of size data from which to compute predicted values
	 * @param iSex   is an integer vector indexing sex (1 = male, 2 = female)
	 * @return dvar_vector of predicted growth increments
	 */
}

dvar_vector model_parameters::calc_growth_increments(const dvector vSizes, const ivector iSex)
{
	{
	if( vSizes.indexmin() != iSex.indexmin() || vSizes.indexmax() != iSex.indexmax() )
	{
		cerr<<"indices don't match..."<<endl;
		ad_exit(1);
	}
	RETURN_ARRAYS_INCREMENT();
	dvar_vector pMoltInc(1,vSizes.indexmax());
	pMoltInc.initialize();
	int h,i;
	for( i = 1; i <= nGrowthObs; i++ )
	{
		h = iSex(i);
		pMoltInc(i) = alpha(h) - beta(h) * vSizes(i);
	}
	RETURN_ARRAYS_DECREMENT();
	return pMoltInc;
	}
	/**
	 * @brief Molt increment as a linear function of pre-molt size.
	 * 
	 * TODO
	 * Option for empirical molt increments.
	 */
}

void model_parameters::calc_growth_increments(void)
{
	int h,l;
	for( h = 1; h <= nsex; h++ )
	{
		for( l = 1; l <= nclass; l++ )
		{
			molt_increment(h)(l) = alpha(h) - beta(h) * mid_points(l);
		}
	}
	/**
	 * \brief Calclate the size transtion matrix.
	 * \Authors Team
	 * \details Calculates the size transition matrix for each sex based on
	 * growth increments, which is a linear function of the size interval, and
	 * the scale parameter for the gamma distribution.  This function does the 
	 * proper integration from the lower to upper size bin, where the mode of 
	 * the growth increment is scaled by the scale parameter.
	 * 
	 * This function loops over sex, then loops over the rows of the size
	 * transition matrix for each sex.  The probability of transitioning from 
	 * size l to size ll is based on the vector molt_increment and the 
	 * scale parameter. In all there are three parameters that define the size
	 * transition matrix (alpha, beta, scale) for each sex.
   	 *
  	 * Issue 112 details some of evolution of code development here
	 */
}

void model_parameters::calc_growth_transition(void)
{
	//cout<<"Start of calc_growth_transition"<<endl;
	int h,l,ll;
	dvariable dMeanSizeAfterMolt;
	dvar_vector psi(1,nclass+1);
	dvar_vector sbi(1,nclass+1);
	dvar_matrix At(1,nclass,1,nclass);
	growth_transition.initialize();
	for( h = 1; h <= nsex; h++ )
	{
		At.initialize();
		sbi = size_breaks / gscale(h);
		for( l = 1; l <= nclass; l++ )
		{
			dMeanSizeAfterMolt = (size_breaks(l) + molt_increment(h)(l)) / gscale(h);
			psi.initialize();
			for( ll = l; ll <= nclass+1; ll++ )
			{
				if( ll <= nclass+1 )
				{
					psi(ll) = cumd_gamma(sbi(ll),dMeanSizeAfterMolt);
				}
			}
			At(l)(l,nclass)  = first_difference(psi(l,nclass+1));
			At(l)(l,nclass)  = At(l)(l,nclass) / sum(At(l));
		}
		growth_transition(h) = At;
	}
	/**
	 * @brief Calculate natural mortality array
	 * @details Natural mortality (M) is a 3d array for sex, year and size.
	 * @return NULL
	 * 
	 * todo:  
	 *      - Add time varying components
	 *      - Size-dependent mortality
	 */
}

void model_parameters::calc_natural_mortality(void)
{
	int h;
	M.initialize();
	for( h = 1; h <= nsex; h++ )
	{
		M(h) = M0;
	}
	// Add random walk to natural mortality rate.
	if (active( m_dev ))
	{
		dvar_vector delta(syr+1,nyr);
		delta.initialize();
		switch( m_type )
		{
			// would this line ever occur if m_dev active?
			case 0:  // constant natural mortality
				delta = 0;
			break;
			case 1:  // random walk in natural mortality
				delta = m_dev.shift(syr+1);
			break;
			case 2:  // cubic splines
			{
				dvector iyr = (m_nodeyear -syr) / (nyr-syr);
				dvector jyr(syr+1,nyr);
				jyr.fill_seqadd(0,1./(nyr-syr-1));
				vcubic_spline_function csf(iyr,m_dev);
				delta = csf(jyr);
			}
			break;
			/*
			JIm Question about below.  I'm not sure if you were intending to
			have this set up as a random walk, where the shift occurs in a specifc year
			to a new state.  I think what Jie had  was just a block wiht a different
			M and it then returns back to the previous state.
			*/
			case 3:  // Specific break points
			        for (int idev=1;idev<=nMdev;idev++)
			  	{
  					delta(m_nodeyear(idev)) = m_dev(idev);
			  	}
			break;
		}
		// Update M by year.
		for(int h = 1; h <= nsex; h++ )
		{
			for(int i = syr+1; i <= nyr; i++ )
			{
				M(h)(i)  = M(h)(i-1) * mfexp(delta(i));
			}
		}
	}
	/**
	 * @brief Calculate total instantaneous mortality rate and survival rate
	 * @details \f$ S = exp(-Z) \f$
	 * @return NULL
	 * 
	 * ISSUE, for some reason the diagonal of S goes to NAN if linear growth model is used.
	 * Due to F.
	 */
}

void model_parameters::calc_total_mortality(void)
{
	int h;
	Z.initialize();
	S.initialize();
	for( h = 1; h <= nsex; h++ )
	{
		Z(h) = M(h) + F(h);
		for(int i = syr; i <= nyr; i++ )
		{
			for(int l = 1; l <= nclass; l++ )
			{
				S(h)(i)(l,l) = mfexp(-Z(h)(i)(l));
			}
		}
		//COUT(F(h));
	}
	/**
	 * \brief Calculate the probability of moulting vs carapace width.
	 * \details Note that the parameters molt_mu and molt cv can only be
	 * estimated in cases where there is new shell and old shell data.
	 * 
	 * Note that the diagonal of the P matrix != 0, otherwise the matrix
	 * is singular in inv(P).
	 */
}

void model_parameters::calc_molting_probability(void)
{
	int l,h;
	molt_probability.initialize();
	P.initialize();
	double tiny = 0.000;
	for( h = 1; h <= nsex; h++ )
	{
		dvariable mu = molt_mu(h);
		dvariable sd = mu* molt_cv(h);
		molt_probability(h) = 1.0 - ((1.0-2.*tiny)*plogis(mid_points,mu,sd) + tiny);
		for( l = 1; l <= nclass; l++ )
		{
			P(h)(l,l) = molt_probability(h)(l);
		}
	}
	/**
	 * @brief calculate size distribution for new recuits.
	 * @details Based on the gamma distribution, calculates the probability
	 * of a new recruit being in size-interval size.
	 * 
	 * TODO: fix the scale on cumd_gamma distribution so beta rbeta is estimable.
	 * 
	 * @param ra is the mean of the distribution.
	 * @param rbeta scales the variance of the distribution
	 */
}

void model_parameters::calc_recruitment_size_distribution(void)
{
	dvariable ralpha = ra / rbeta;
	dvar_vector x(1,nclass+1);
	for(int l = 1; l <= nclass+1; l++ )
	{
		x(l) = cumd_gamma(size_breaks(l)/rbeta,ralpha);
	}
	rec_sdd  = first_difference(x);
	rec_sdd /= sum(rec_sdd);   // Standardize so each row sums to 1.0
	/**
	 * @brief initialiaze populations numbers-at-length in syr
	 * @author Steve Martell
	 * @details This function initializes the populations numbers-at-length
	 * in the initial year of the model.  
	 * 
	 * Psuedocode:  See note from Dave Fournier.
	 * 
	 * For the initial numbers-at-lengt a vector of deviates is estimated,
	 * one for each size class, and have the option to initialize
	 * the model at unfished equilibrium, or some other steady state condition.
	 *  
	 *  Dec 11, 2014. Martell & Ianelli at snowgoose.  We had a discussion regarding
	 *  how to deal with the joint probability of molting and growing to a new size
	 *  interval for a given length, and the probability of not molting.  We settled 
	 *  on using the size-tranistion matrix to represent this joint probability, where
	 *  the diagonal of the matrix to represent the probability of surviving and 
	 *  molting to a new size interval. The upper diagonal of the size-transition matrix
	 *  represent the probability of growing to size interval j' given size interval j.
	 *  
	 *  Oldshell crabs are then the column vector of 1-molt_probabiltiy times the 
	 *  numbers-at-length, and the Newshell crabs is the column vector of molt_probability
	 *  times the number-at-length.
	 *  
	 *  Jan 1, 2015.  Changed how the equilibrium calculation is done.  Use a numerical
	 *  approach to solve the newshell oldshell initial abundance.
	 *  
	 *  Jan 3, 2015.  Working with John Levitt on analytical solution instead of the 
	 *  numerical approach.  Think we have a soln.  
	 *  
	 *  Notation:
	 *      n = vector of newshell crabs
	 *      o = vector of oldshell crabs
	 *      P = diagonal matrix of molting probabilities by size
	 *      S = diagonal matrix of survival rates by size
	 *      A = Size transition matrix.
	 *      r = vector of new recruits (newshell)
	 *      I = identity matrix.
	 *  
	 *  The following equations represent the dynamics of newshell and oldshell crabs.
	 *      n = nSPA + oSPA + r                     (1)
	 *      o = oS(I-P)A + nS(I-P)A                 (2)
	 *  Objective is to solve the above equations for n and o repsectively.  Starting
	 *  with o:
	 *      o = n(I-P)S[I-(I-P)S]^(-1)              (3)
	 *  next substitute (3) into (1) and solve for n
	 *      n = nPSA + n(I-P)S[I-(I-P)S]^(-1)PSA + r
	 *  
	 *  let B = [I-(I-P)S]^(-1)
	 *      
	 *      n - nPSA - n(I-P)SBPSA = r
	 *      n(I - PSA - (I-P)SBPSA) = r
	 *  
	 *  let C = (I - PSA - (I-P)SBPSA)
	 *  
	 *  then n = C^(-1) r                           (4)
	 *  –––-—————————————————————————————————————————————————————————————————————————----
	 * 
	 *  April 28, 2015.  There is no case here for initializing the model at unfished
	 *  equilibrium conditions.  Need to fix this for SRA purposes.  SJDM. 
	 */
}

void model_parameters::calc_initial_numbers_at_length(void)
{
	dvariable log_initial_recruits;
	//N.initialize();
	d3_newShell.initialize();
	d3_oldShell.initialize();
	// Initial recrutment.
	if ( bInitializeUnfished )
	{
		log_initial_recruits = logR0;
	}
	else
	{
		log_initial_recruits = logRini;
	}
	recruits(syr) = exp(log_initial_recruits);
	dvar_vector rt = 1.0/nsex * recruits(syr) * rec_sdd;
	// Analytical equilibrium soln.
	int ig;
	d3_N.initialize();
	dmatrix Id = identity_matrix(1,nclass);
	dvar_vector  x(1,nclass);
	dvar_vector  y(1,nclass);
	dvar_matrix  A(1,nclass,1,nclass);
	dvar_matrix _S(1,nclass,1,nclass);
	_S.initialize();
	for(int h = 1; h <= nsex; h++ )
	{
		A = growth_transition(h);
		// Unfished conditions
		if ( bInitializeUnfished )
		{
			for(int i = 1; i <= nclass; i++ )
			{
				_S(i,i) = exp(-M(h)(syr)(i));
			}
		}
		// Steady-state fished conditions
		else
		{
			_S = S(h)(syr);
		}
		// Single shell condition
		if ( nshell == 1 && nmature == 1 )
		{
			calc_equilibrium(x,A,_S,rt);
			ig = pntr_hmo(h,1,1);
			d3_N(ig)(syr) = elem_prod(x , exp(rec_ini));
		}
		// Continuous molt (newshell/oldshell)
		if ( nshell == 2 && nmature == 1 )
		{
			calc_equilibrium(x,y,A,_S,P(h),rt);
			ig = pntr_hmo(h,1,1);
			d3_N(ig)(syr)   = elem_prod(x , exp(rec_ini));;
			d3_N(ig+1)(syr) = elem_prod(y , exp(rec_ini));;
		}
		// Insert terminal molt case here.
	}
	if(verbose == 1) COUT(d3_N(1)(syr));
	// cout<<"End of calc_initial_numbers_at_length"<<endl; 
	/**
	 * @brief Update numbers-at-length
	 * @author Team
	 * @details  Numbers at length are propagated each year for each sex based on the 
	 * size transition matrix and a vector of size-specifc survival rates. The columns
	 * of the size-transition matrix are multiplied by the size-specific survival rate
	 * (a scalar).  New recruits are added based on the estimated aveerage recruitment and 
	 * annual deviate, multiplied by a vector of size-proportions (rec_sdd).
	 */
}

void model_parameters::update_population_numbers_at_length(void)
{
	int h,i,ig,o,m;
	dmatrix Id = identity_matrix(1,nclass); 
	dvar_vector rt(1,nclass);
	dvar_vector  x(1,nclass);
	dvar_vector  y(1,nclass);
	dvar_matrix t1(1,nclass,1,nclass);
	dvar_matrix  A(1,nclass,1,nclass);
	dvar_matrix At(1,nclass,1,nclass);
	if ( bInitializeUnfished )
	{
		recruits(syr+1,nyr) = mfexp(logR0);
	}
	else
	{
		recruits(syr+1,nyr) = mfexp(logRbar);	
	}
	for( i = syr; i <= nyr; i++ )
	{
		if( i > syr )
		{
			recruits(i) *= mfexp(rec_dev(i));
		}
		rt = (1.0/nsex * recruits(i)) * rec_sdd;
		for( ig = 1; ig <= n_grp; ig++ )
		{
			h = isex(ig);
			m = imature(ig);
			o = ishell(ig);
			if( o == 1 )    // newshell
			{
				A  = growth_transition(h) * S(h)(i);
				x = d3_N(ig)(i);
				d3_N(ig)(i+1) = elem_prod(x,diagonal(P(h))) * A + rt;
			}
			if( o == 2 )    // oldshell
			{
				x  = d3_N(ig)(i);
				y  = d3_N(ig-1)(i);
				t1 = (Id - P(h)) * S(h)(i);
				// add oldshell non-terminal molts to newshell
				d3_N(ig-1)(i+1) += elem_prod(x,diagonal(P(h))) * A;
				// oldshell
				d3_N(ig)(i+1) = (x+d3_N(ig-1)(i)) * t1;
			}
			if ( o == 1 && m == 2 )     // terminal molt to new shell.
			{
			}
			if ( o == 2 && m == 2 )     // terminal molt newshell to oldshell.
			{
			}
		}
	}
	if(verbose  == 1) COUT(d3_N(1)+d3_N(2));
	/**
	 * @brief Calculate stock recruitment relationship.
	 * @details  Assuming a Beverton-Holt relationship between the 
	 * mature biomass (user defined) and the annual recruits.  Note 
	 * that we derive so and bb in R = so * MB / (1 + bb * Mb)
	 * from Ro and steepness (leading parameters defined in theta).
	 *
	 * NOTES:
	 * if nSRR_flag == 1 then use a Beverton-Holt model to compute the 
	 * recruitment deviations for minimization.
	 */
}

void model_parameters::calc_stock_recruitment_relationship(void)
{
	dvariable so, bb;
	dvariable ro = mfexp(logR0);
	dvariable phiB;
	dvariable reck = 4.*steepness/(1.-steepness);
	dvar_matrix _A(1,nclass,1,nclass);
	dvar_matrix _S(1,nclass,1,nclass);
	_A.initialize();
	_S.initialize();
	// get unfished mature male biomass per recruit.
	phiB = 0.0;
	for(int h = 1; h <= nsex; h++ )
	{
		for (int l = 1; l <= nclass; ++l)
		{
			_S(l,l) = exp(-M(h)(syr)(l));
		}
		_A = growth_transition(h);
		dvar_vector x(1,nclass);
		dvar_vector y(1,nclass);
		double lam;
		h <= 1 ? lam = spr_lambda: lam = (1.0 - spr_lambda);
		// Single shell condition
		if ( nshell == 1 && nmature == 1)
		{
			calc_equilibrium(x,_A,_S,rec_sdd);
			phiB += lam * x * elem_prod(mean_wt(h),maturity(h));
		}
		// Continuous molt (newshell/oldshell)
		if ( nshell == 2 && nmature == 1)
		{
			calc_equilibrium(x,y,_A,_S,P(h),rec_sdd);
			phiB += lam * x * elem_prod(mean_wt(h),maturity(h))
			     +  lam * y * elem_prod(mean_wt(h),maturity(h));
		}
		// Insert terminal molt case here.
	}
	dvariable bo = ro * phiB;
	so   = reck * ro / bo;
	bb   = (reck -1.0 ) / bo;
	dvar_vector ssb  = calc_ssb().shift(syr+1);
	dvar_vector rhat = elem_div(so * ssb , 1.0 + bb* ssb);
	// residuals
	int byr = syr+1;
	res_recruit.initialize();
	dvariable sigR = mfexp(logSigmaR);
	dvariable sig2R = 0.5 * sigR * sigR;
	switch(nSRR_flag)
	{
		case 0: // NO SRR
			//res_recruit(syr)     = log(recruits(syr)) - logRbar;
			res_recruit(byr,nyr) = log(recruits(byr,nyr))
			                       - (1.0-rho) * logRbar
			                       - rho * log(++recruits(byr-1,nyr-1))
			                       + sig2R;
		break;
		case 1:	// SRR model
			//xi(byr,nyr) = log(recruits(byr,nyr)) - log(rhat(byr,nyr)) + sig2R;
			res_recruit(byr,nyr) = log(recruits(byr,nyr))
			                       - (1.0-rho) * log(rhat(byr,nyr))
			                       - rho * log(++recruits(byr-1,nyr-1))
			                       + sig2R;
		break;
	}
	/**
	 * @brief Calculate predicted catch observations
	 * @details The function uses the Baranov catch equation to predict the retained
	 * and discarded catch.
	 * 
	 * Assumptions:
	 *  1) retained (landed catch) is assume to be newshell male only.
	 *  2) discards are all females (new and old) and male only crab.
	 *  3) Natural and fishing mortality occur simultaneously.
	 *  4) discard is the total number of crab caught and discarded.
	 * 
	 * @param  [description]
	 * @return NULL
	 */
}

void model_parameters::calc_predicted_catch(void)
{
	int h,i,j,k,ig;
	int type,unit;
	pre_catch.initialize();
	dvariable tmp_ft;
	dvar_vector sel(1,nclass);
	dvar_vector nal(1,nclass);      // numbers or biomass at length.
	for(int kk = 1; kk <= nCatchDF; kk++ )
	{
		for( j = 1; j <= nCatchRows(kk); j++ )
		{   
			i = dCatchData(kk,j,1);        // year index
			k = dCatchData(kk,j,3);        // gear index
			h = dCatchData(kk,j,4);        // sex index
			// Type of catch (retained = 1, discard = 2)
			type = int(dCatchData(kk,j,7));
			// Units of catch equation (1 = biomass, 2 = numbers)
			unit = int(dCatchData(kk)(j,8));
			// Total catch
			if(h)   // sex specific
			{
				nal.initialize();
				sel = log_slx_capture(k)(h)(i);
				switch(type)
				{
					case 1:     // retained catch
						// Question here about what the retained catch is.
						// Should probably include shell condition here as well.
						// Now assuming both old and new shell are retained.
						sel = exp( sel + log_slx_retaind(k)(h)(i) );
						for(int m = 1; m <= nmature; m++ )
						{   
							for(int o = 1; o <= nshell; o++ )
							{
								ig   = pntr_hmo(h,m,o); 
								nal += d3_N(ig)(i);
							}
						}
					break;
					case 2:     // discard catch
						sel = elem_prod(exp(sel),1.0 - exp( log_slx_retaind(k)(h)(i) ));
						for(int m = 1; m <= nmature; m++ )
						{
							for(int o = 1; o <= nshell; o++ )
							{
								ig   = pntr_hmo(h,m,o);
								nal += d3_N(ig)(i);
							}
						}
					break;
				}
				tmp_ft = ft(k)(h)(i);
				nal = (unit==1) ? elem_prod(nal,mean_wt(h)) : nal;
				pre_catch(kk,j) = nal * elem_div(elem_prod(tmp_ft * sel, 1.0 - exp(-Z(h)(i))), Z(h)(i));
			}
			else    // sexes combibed
			{
				for( h = 1; h <= nsex; h++ )
				{
					nal.initialize();
					sel = log_slx_capture(k)(h)(i);
					switch(type)
					{
						case 1:     // retained catch
							sel = exp( sel + log_slx_retaind(k)(h)(i) );
							for(int m = 1; m <= nmature; m++ )
							{
								ig   = pntr_hmo(h,m,1); //indexes new shell.
								nal += d3_N(ig)(i);
							}
						break;
						case 2:     // discard catch
							sel = 
								elem_prod(exp(sel),1.0 - exp( log_slx_retaind(k)(h)(i) ));
							//COUT(sel)
							for(int m = 1; m <= nmature; m++ )
							{
								for(int o = 1; o <= nshell; o++ )
								{
									ig   = pntr_hmo(h,m,o);
									nal += d3_N(ig)(i);
								}
							}
						break;
					}
					tmp_ft = ft(k)(h)(i);
					nal = (unit==1) ? elem_prod(nal,mean_wt(h)) : nal;
					pre_catch(kk,j) += nal * elem_div(elem_prod(tmp_ft*sel,1.0-exp(-Z(h)(i))),Z(h)(i));
				}
			}
		}
		// Catch residuals
		//COUT(pre_catch(kk));
		res_catch(kk) = log(obs_catch(kk)) - log(pre_catch(kk));
		if(verbose == 1) COUT(pre_catch(kk)(1));
	}
	/**
	 * @brief Calculate predicted relative abundance and residuals
	 * @author Steve Martell
	 * 
	 * @details This function uses the conditional mle for q to scale
	 * the population to the relative abundance index.  Assumed errors in 
	 * relative abundance are lognormal.  Currently assumes that the CPUE
	 * index is made up of both retained and discarded crabs.
	 * 
	 * Question regarding use of shell condition in the relative abundance index.
	 * Currenlty there is no shell condition information in the CPUE data, should
	 * there be? Similarly, there is no mature immature information, should there be?
	 */
}

void model_parameters::calc_relative_abundance(void)
{
	int g,h,i,j,k,ig;
	int unit;
	dvar_vector nal(1,nclass);  // numbers at length
	dvar_vector sel(1,nclass);  // selectivity at length
	for( k = 1; k <= nSurveys; k++ )
	{
		dvar_vector V(1,nSurveyRows(k));    
		V.initialize();
		for( j = 1; j <= nSurveyRows(k); j++ )
		{
			nal.initialize();
			i = dSurveyData(k)(j)(1);       // year index
			g = dSurveyData(k)(j)(3);       // gear index
			h = dSurveyData(k)(j)(4);       //  sex index
			unit = dSurveyData(k)(j)(7);    // units 1==biomass 2==Numbers
			if(h)
			{
				sel = exp(log_slx_capture(g)(h)(i));
				for(int m = 1; m <= nmature; m++ )
				{
					for(int o = 1; o <= nshell; o++ )
					{
						ig   = pntr_hmo(h,m,o);
						nal +=  (unit==1)? 
								elem_prod(d3_N(ig)(i),mean_wt(h)):
								d3_N(ig)(i);
					}
				}
				V(j) = nal * sel;
			}
			else
			{
				for( h = 1; h <= nsex; h++ )
				{
					sel = exp(log_slx_capture(g)(h)(i));
					for(int m = 1; m <= nmature; m++ )
					{
						for(int o = 1; o <= nshell; o++ )
						{
							ig   = pntr_hmo(h,m,o);
							nal +=  (unit==1)? 
									elem_prod(d3_N(ig)(i),mean_wt(h)): 
									d3_N(ig)(i);
						}
					}
					V(j) += nal * sel;
				}
			}
		} // nSurveyRows(k)
		dvar_vector zt = log(obs_cpue(k)) - log(V);
		dvariable zbar = mean(zt);
		res_cpue(k)    = zt - zbar;
		survey_q(k)    = mfexp(zbar);
		pre_cpue(k)    = survey_q(k) * V;
	}
	/**
	 * @brief Calculate predicted size composition data.
         *
	 * @details Predicted size composition data are given in proportions.
	 * Size composition strata:
	 *  - sex  (0 = both sexes, 1 = male, 2 = female)
	 *  - type (0 = all catch, 1 = retained, 2 = discard)
	 *  - shell condition (0 = all, 1 = new shell, 2 = oldshell)
	 *  - mature or immature (0 = both, 1 = immature, 2 = mature)
	 * 
	 * NB Sitting in a campground on the Orgeon Coast writing this code,
	 * with baby Tabitha sleeping on my back.
	 * 
	 * TODO: 
	 *  - add pointers for shell type.   DONE
	 *  - add pointers for maturity state. DONE
	 *  - need pointer for retained vs. discarded.
	 *  
	 *  Jan 5, 2015.
	 *  Size compostion data can come in a number of forms.
	 *  Given sex, maturity and 3 shell conditions, there are 12 possible
	 *  combinations for adding up the numbers at length (nal).
	 *                          Shell
	 *    Sex     Maturity        condition   Description
	 *    _____________________________________________________________
	 *    Male    0               1           immature, new shell
	 * !  Male    0               2           immature, old shell
	 * !  Male    0               0           immature, new & old shell               1               Male, immature, new shell
	 *    Male    1               1             mature, new shell
	 *    Male    1               2             mature, old shell
	 *    Male    1               0             mature, new & old shell
	 *  Female    0               1           immature, new shell
	 * !Female    0               2           immature, old shell
	 * !Female    0               0           immature, new & old shell
	 *  Female    1               1             mature, new shell
	 *  Female    1               2             mature, old shell
	 *  Female    1               0             mature, new & old shell
	 *    _____________________________________________________________
	 *  
	 *  Call function to get the appropriate numbers-at-length.
	 *  
	 *  TODO:
	 *  [x] Check to ensure new shell old shell is working.
	 *  [ ] Add maturity component for data sets with mature old and mature new.
	 *  [ ] Issue 53, comps/total(sex,shell cond) 
	 */
}

void model_parameters::calc_predicted_composition(void)
{
	int h,i,j,k,ig;
	int type,shell,bmature ;
	d3_pre_size_comps.initialize();
	dvar_vector dNtmp(1,nclass);
	dvar_vector dNtot(1,nclass);
	dvar_vector   nal(1,nclass);
	for(int ii = 1; ii <= nSizeComps; ii++ )
	{
		for(int jj = 1; jj <= nSizeCompRows(ii); jj++ )
		{
			dNtmp.initialize();
			dNtot.initialize();
			nal.initialize();
			i        = d3_SizeComps(ii)(jj,-7);     // year
			j        = d3_SizeComps(ii)(jj,-6);     // seas
			k        = d3_SizeComps(ii)(jj,-5);     // gear
			h        = d3_SizeComps(ii)(jj,-4);     // sex
			type     = d3_SizeComps(ii)(jj,-3);     // retained or discard
			shell    = d3_SizeComps(ii)(jj,-2);     // shell condition
			bmature  = d3_SizeComps(ii)(jj,-1);     // boolean for maturity
			if(h) // sex specific
			{
				dvar_vector sel = exp(log_slx_capture(k)(h)(i));
				dvar_vector ret = exp(log_slx_retaind(k)(h)(i));
				dvar_vector dis = exp(log_slx_discard(k)(h)(i));
				// dvar_vector tmp = N(h)(i);
				for(int m = 1; m <= nmature; m++ )
				{
					for(int o = 1; o <= nshell; o++ )
					{
						ig   = pntr_hmo(h,m,o);
						if(shell == 0) nal += d3_N(ig)(i);
						if(shell == o) nal += d3_N(ig)(i);
					}
				}
				dvar_vector tmp = nal;
				switch (type)
				{
					case 1:     // retained
						dNtmp = elem_prod(tmp,elem_prod(sel,ret));
					break;
					case 2:     // discarded
						dNtmp = elem_prod(tmp,elem_prod(sel,dis));
					break;
					default:	// both retained and discarded
						dNtmp = elem_prod(tmp,sel);
					break;
				}
			}
			else // sexes combined in the observations
			{
				for( h = 1; h <= nsex; h++ )
				{
					dvar_vector sel = exp(log_slx_capture(k)(h)(i));
					dvar_vector ret = exp(log_slx_retaind(k)(h)(i));
					dvar_vector dis = exp(log_slx_discard(k)(h)(i));
					// dvar_vector tmp = N(h)(i);
					for(int m = 1; m <= nmature; m++ )
					{
						for(int o = 1; o <= nshell; o++ )
						{
							ig   = pntr_hmo(h,m,o);
							if(shell == 0) nal += d3_N(ig)(i);
							if(shell == o) nal += d3_N(ig)(i);
						}
					}
					dvar_vector tmp = nal;
					switch (type)
					{
						case 1:
							dNtmp += elem_prod(tmp,ret);
						break;
						case 2:
							dNtmp += elem_prod(tmp,dis);
						break;
						default:
							dNtmp += elem_prod(tmp,sel);
						break;
					}
				}
			}
			d3_pre_size_comps(ii)(jj) = dNtmp / sum(dNtmp);
		}
	}
}

dvariable model_parameters::get_prior_pdf(const int &pType, const dvariable &theta, const double &p1, const double &p2)
{
	{
		dvariable prior_pdf;
		switch(pType)
			{
				// uniform
				case 0: 
					if ( (p2-p1) > 0 )
					{
						prior_pdf = -log(1.0 / (p2-p1));
					}
					else
					{
						cerr <<"Error in uniform prior, p1 > p2.\n";
						ad_exit(1);
					}
				break;
				// normal
				case 1:
					// COUT(p1);COUT(p2);
					prior_pdf = dnorm(theta,p1,p2);
					// COUT(prior_pdf);
				break;
				// lognormal
				case 2:
					prior_pdf = dlnorm(theta,log(p1),p2);
				break;
				// beta
				case 3:
					//lb = theta_control(i,2);
					//ub = theta_control(i,3);
					//prior_pdf = dbeta((theta-lb)/(ub-lb),p1,p2);
					prior_pdf = dbeta(theta,p1,p2);
				break;
				// gamma
				case 4:
					prior_pdf = dgamma(theta,p1,p2);
				break;
			}
			return prior_pdf;
	}
	/**
	 * @brief Calculate prior density functions for leading parameters.
	 * @details 
	 *  - case 0 is a uniform density between the lower and upper bounds.
	 *  - case 1 is a normal density with mean = p1 and sd = p2
	 *  - case 2 is a lognormal density with mean = log(p1) and sd = p2
	 *  - case 3 is a beta density bounded between lb-ub with p1 and p2 as alpha & beta
	 *  - case 4 is a gamma density with parameters p1 and p2.
	 *  
	 *  TODO
	 *  Make this a generic function.
	 *  Agrs would be vector of parameters, and matrix of controls
	 *  @param theta a vector of parameters
	 *  @param C matrix of controls (priorType, p1, p2, lb, ub)
	 *  @return vector of prior densities for each parameter
	 */
}

void model_parameters::calculate_prior_densities(void)
{
	double p1,p2;
	double lb,ub;
	priorDensity.initialize();
	for (int i = 1; i <= ntheta; i++)
	{
		if (active(theta(i)))
		{
			int priorType = int(theta_control(i,5));
			p1 = theta_control(i,6);
			p2 = theta_control(i,7);
			dvariable x = theta(i);
			if (priorType == 3)
			{
				lb = theta_control(i,2);
				ub = theta_control(i,3);
				x = (x-lb)/(ub-lb);
			}
			priorDensity(i) = get_prior_pdf(priorType, x, p1, p2);
		}
	}
	for (int i = 1; i <= nGrwth; i++)
	{
		if (active(Grwth(i)))
		{
			int priorType = int(Grwth_control(i,5));
			p1 = Grwth_control(i,6);
			p2 = Grwth_control(i,7);
			dvariable x = Grwth(i);
			if (priorType == 3)
			{
				lb = Grwth_control(i,2);
				ub = Grwth_control(i,3);
				x = (x-lb)/(ub-lb);
			}
			priorDensity(ntheta+i) = get_prior_pdf(priorType, x, p1, p2);
		}
	}
	// ---Continue with catchability priors-----------------------
	int iprior = ntheta + nGrwth + 1; 
	for (int i = 1; i <= nSurveys; i++)
	{
		int itype = int(prior_qtype(i));
		switch(itype)
		{
			// Analytical soln, no prior (uniform, uniformative)
			case 0:
			break;
			// Prior on analytical soln, log-normal
			case 1:
				priorDensity(iprior) = dnorm(log(survey_q(i)), log(prior_qbar(i)), prior_qsd(i));
			break;
		}
		iprior++;
	}
	/**
	 * @brief calculate objective function
	 * @details 
	 * 
	 * Likelihood components
	 *  -# likelihood of the catch data (assume lognormal error)
	 *  -# likelihood of relative abundance data
	 *  -# likelihood of size composition data
	 * 
	 * Penalty components
	 *  -# Penalty on log_fdev to ensure they sum to zero.
	 *  -# Penalty to regularize values of log_fbar.
	 *  -# Penalty to constrain random walk in natural mortaliy rates
	 */
}

void model_parameters::calc_objective_function(void)
{
	// |---------------------------------------------------------------------------------|
	// | NEGATIVE LOGLIKELIHOOD COMPONENTS FOR THE OBJECTIVE FUNCTION                    |
	// |---------------------------------------------------------------------------------|
	nloglike.initialize();
	// 1) Likelihood of the catch data.
	if (verbose == 1) COUT(res_catch(1));
	for (int k = 1; k <= nCatchDF; k++)
	{
		dvector catch_sd = sqrt(log(1.0 + square(catch_cv(k))));
		nloglike(1,k) += dnorm(res_catch(k), catch_sd);
	}
	// 2) Likelihood of the relative abundance data.
        if (verbose == 1) COUT(res_cpue(1));
	for (int k = 1; k <= nSurveys; k++)
	{
		dvector cpue_sd = sqrt(log(1.0 + square(cpue_cv(k))));
		nloglike(2,k) += cpue_lambda(k) * dnorm(res_cpue(k), cpue_sd(k));
	}
	// 3) Likelihood for size composition data. 
	for (int ii = 1; ii <= nSizeComps; ii++)
	{
		dmatrix     O = d3_obs_size_comps(ii);
		dvar_matrix P = d3_pre_size_comps(ii);
		dvar_vector log_effn = log(exp(log_vn(ii)) * size_comp_sample_size(ii));
		d3_res_size_comps.initialize();
		bool bCmp = bTailCompression(ii);
		acl::negativeLogLikelihood *ploglike;
		switch(nAgeCompType(ii))
		{
			case 0:  // ignore composition data in model fitting.
				ploglike = NULL;
			break;
			case 1:  // multinomial with fixed or estimated n
				ploglike = new acl::multinomial(O, bCmp);
			break;
			case 2:  // robust approximation to the multinomial
				if(current_phase() <= 3 || !last_phase())
					ploglike = new acl::multinomial(O, bCmp);
				else
					ploglike = new acl::robust_multi(O, bCmp);
			break;
		}
		// Compute residuals in the last phase.
		if (last_phase() && ploglike != NULL)
		{
			d3_res_size_comps(ii) = ploglike->residual(log_effn, P);
		}
		// now compute the likelihood.
		if (ploglike != NULL)
		{
			nloglike(3,ii) += ploglike->nloglike(log_effn, P);
		}
	}
	// 4) Likelihood for recruitment deviations.
	if (active(rec_dev))
	{
		dvariable sigR = mfexp(logSigmaR);
		switch(nSRR_flag)
		{
			case 0:
				//nloglike(4,1) = dnorm(rec_dev, sigR);
				nloglike(4,1) = dnorm(res_recruit, sigR);
				nloglike(4,1) += dnorm(rec_ini, sigR);
			break;
			case 1:
				nloglike(4,1) = dnorm(res_recruit, sigR);
			break;
		}
	}
	// 5) Likelihood for growth increment data
	if (!bUseEmpiricalGrowth && (active(Grwth(1)) || active(Grwth(2))))
	{
		dvar_vector MoltIncPred = calc_growth_increments(dPreMoltSize, iMoltIncSex);
		nloglike(5,1) = dnorm(log(dMoltInc) - log(MoltIncPred), dMoltIncCV);
	}
	// |---------------------------------------------------------------------------------|
	// | PENALTIES AND CONSTRAINTS                                                       |
	// |---------------------------------------------------------------------------------|
	nlogPenalty.initialize();
	// 1) Penalty on log_fdev to ensure they sum to zero 
	for(int k = 1; k <= nfleet; k++ )
	{
		dvariable s     = mean(log_fdev(k));
		nlogPenalty(1) += 10000.0*s*s;
		dvariable r     = mean(log_fdov(k));
		nlogPenalty(1) += 10000.0*r*r;
	}
	// 2) Penalty on mean F to regularize the solution.
	int irow=1;
	if (last_phase()) irow=2;
	dvariable fbar;
	dvariable log_fbar;
	for (int k = 1; k <= nfleet; k++)
	{
		fbar = mean(ft(k)(1));
		if (pen_fbar(k) > 0  && fbar != 0)
		{
			log_fbar = log(fbar);
			nlogPenalty(2) += dnorm(log_fbar, log(pen_fbar(k)), pen_fstd(irow,k));
		}
	}
	// 3) Penalty to constrain M in random walk
	if(active(m_dev))
	{
		nlogPenalty(3) = dnorm(m_dev, m_stdev);
	}
	// 4 Penalty on recruitment devs.
	if(active(rec_dev) && nSRR_flag !=0)
	{
		nlogPenalty(4) = dnorm(rec_dev, 1.0);
	}
	if(active(rec_ini) && nSRR_flag !=0)
	{
		nlogPenalty(5) = dnorm(rec_ini, 1.0);
	}
	if(active(rec_dev))
	{
		nlogPenalty(6) = dnorm(first_difference(rec_dev), 1.0);
	}
	objfun = sum(nloglike) + sum(nlogPenalty) + sum(priorDensity);
	if (verbose == 2) 
	{
		COUT(objfun);
		COUT(nloglike);
		COUT(nlogPenalty);
		COUT(priorDensity);
	}
